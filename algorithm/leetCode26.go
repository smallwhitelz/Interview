package main

// 26. 删除有序数组中的重复项

// 输入：nums = [0,0,1,1,1,2,2,3,3,4]
// 输出：5, nums = [0,1,2,3,4]
// 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。

// 双指针
// 思路：这里之所以两个值相等的时候跳过，我理解其实是给下一个不相等的值占位
// 而j这个慢指针相当于是将原先的nums开辟了一个新数组存值
func removeDuplicates(nums []int) int {
	n := len(nums)
	j := 0
	for i := 0; i < n; i++ {
		if nums[i] != nums[j] {
			nums[j+1] = nums[i]
			j++
		}
	}
	return j + 1
}

// 通用玩法
// 为了让解法更具有一般性，我们将原问题的「最多保留 1 位」修改为「最多保留 k 位」。
//
// 对于此类问题，我们应该进行如下考虑：
//
// 由于是保留 k 个相同数字，对于前 k 个数字，我们可以直接保留。
// 对于后面的任意数字，能够保留的前提是：与当前写入的位置前面的第 k 个元素进行比较，不相同则保留。
// 举个例子，我们令 k=1，假设有样例：[3,3,3,3,4,4,4,5,5,5]
//
// 设定变量 idx，指向待插入位置。idx 初始值为 0，目标数组为 []
//
// 首先我们先让第 1 位直接保留（性质 1）。idx 变为 1，目标数组为 [3]
//
// 继续往后遍历，能够保留的前提是与 idx 的前面 1 位元素不同（性质 2），因此我们会跳过剩余的 3，将第一个 4 追加进去。idx 变为 2，目标数组为 [3,4]
//
// 继续这个过程，跳过剩余的 4，将第一个 5 追加进去。idx 变为 3，目标数组为 [3,4,5]
//
// 当整个数组被扫描完，最终我们得到了目标数组 [3,4,5] 和 答案 idx 为 3。
func removeDuplicatesV1(nums []int) int {
	k := 1
	idx := 0
	for _, num := range nums {
		if idx < k || nums[idx-k] != num {
			nums[idx] = num
			idx++
		}
	}
	return idx
}

func main() {

}
