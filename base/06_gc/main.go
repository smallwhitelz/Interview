package main

import "fmt"

// 问题：Go 中的 GC 如何调优？
// Go的gc调优可以从两点来说
// 1. 要么少产生垃圾
// 2. 要么调优gc算法

// 调大GoGC可以降低gc的频率，也就说当前的堆在上次gc后增长100后就gc，你调大后，增长200后再gc，这样就减少了gc次数和停顿
// 但是占用了更多的内存
// 这也就是说钞能力，用硬件资源换性能

// 再一个使用内存逃逸分析，减少分配到堆上的对象
// 使用buff pool或者对象池的技术，复用已有的对象，减少创建新对象，比如类似gin里面就利用对象池技术减少gin.Context的创建

// 问题： Go 中的内存逃逸现象是什么？
// 内存逃逸是指如果一个函数的局部变量，可能会被外部引用，导致这个变量在函数返回后都不能释放，编译器就认为这个变量逃逸了，就会把它放到堆上
// 简单理解就是一个东西，被函数创建出来，然后返回给了调用者，就有可能会逃逸，为什么说有可能？因为Go本身就是值传递，如果你返回的是基本类型
// 或者是比较小的结构体，而不是指针，就有可能不会内存逃逸
// 常见的场景：
// 返回一个局部变量的指针
// 返回make命令创建的对象
// 通过channel发送局部变量
// 缺陷：一个对象分配到堆上，一个是分配效率比较低，再一个会被gc管理，也就是产生了更多的垃圾，加重了垃圾回收的负担
// 在优化的时候，分析内存逃逸也是一个策略，可以使用 go build -gcflags="-m" yourfile.go进行分析
// 但是一般情况下，业务代码中，往往调优一个sql都比分析半天内存逃逸来的优化有用
// SQL 查询优化和函数调用优化带来的收益更为直接和显著，因为它们直接影响到程序的执行速度、I/O 操作以及数据库的响应。
// 而 内存逃逸分析优化则是一个间接的、微观的优化，通常需要在特定场景下才能看到显著效果。

// foo 返回了局部变量 x 的地址，x 必须存活到 foo 返回后才能被外部使用
// 函数 foo 返回了局部变量 x 的地址。为了保证调用者仍能使用这块内存，编译器会把 x 分配到堆上（逃逸到堆），而不是分配到栈上。
func foo() *int {
	x := 10   // x 默认分配在栈上
	return &x // 将 x 的地址返回，编译器检测到 x 会被函数外部引用
}

// bar 返回了一个新创建的切片，切片底层数组一定分配在堆上
// 无论是否返回，make 创建的切片（map、channel、slice、字符串等）底层的数据结构都会分配到堆上，以便在函数返回后继续使用。
func bar() []int {
	s := make([]int, 3) // make 创建的 slice 底层数组总是分配在堆上
	s[0], s[1], s[2] = 1, 2, 3
	return s // 返回 slice header，但它指向的底层数组已在堆上
}

// 在 baz 中，局部变量 x 的地址被通过 channel 发送到外部 goroutine。编译器必须保证 x 在所有接收者使用完之前都不会被释放，所以将它提升到堆上。
func baz(ch chan *int) {
	x := 100 // 局部变量 x
	ch <- &x // 将 x 的地址发送到外部
}

func main() {
	//p := foo()      // p 指向的 x 实际上已经被提升到堆上
	//fmt.Println(*p) // 输出 42

	ch := make(chan *int)
	go baz(ch)      // 启动一个 goroutine，将 x 发送到主 goroutine
	p := <-ch       // 从 channel 接收指针
	fmt.Println(*p) // 输出 100
}
